(()=>{"use strict";require("dotenv/config"),require("express-async-errors");const e=require("express"),t=require("cors"),s=require("http-status-codes"),a=require("nanoid"),r=require("mysql2").createPool({host:"localhost",user:"root",password:"root",database:"lenderapp"}).promise(),o=require("bcryptjs"),n=require("jsonwebtoken"),i=async e=>{try{const[t,s]=await r.query("SELECT * FROM empDetails WHERE id = ?",[e]);return 0===t.length?null:t[0]}catch(e){throw new Error("Error retrieving employee from the database")}},c=e.Router();c.get("/getAllEmployees",(async(e,t)=>{try{const{phoneNumber:a,EmailAddr:o,Role:n,centerId:i}=e.query,{employees:c,count:d}=await(async({phoneNumber:e,EmailAddr:t,Role:s,centerId:a})=>{try{let o="SELECT * FROM empDetails WHERE 1";const n=[];e&&(o+=" AND Phone = ?",n.push(e)),t&&(o+=" AND EmailAddr = ?",n.push(t)),s&&(o+=" AND Role = ?",n.push(s)),a&&(o+=" AND centerId = ?",n.push(a));const[i,c]=await r.query(o,n);return{employees:i,count:i.length}}catch(e){throw new Error("Error retrieving employees from the database")}})({phoneNumber:a,EmailAddr:o,Role:n,centerId:i}),u=`Retrieved ${d} employees`;t.status(s.StatusCodes.OK).json({message:u,employees:c,count:d})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error retrieving employees",error:e.message})}})),c.get("/getEmployeeById/:id",(async(e,t)=>{try{const{id:a}=e.params;if(!a)return t.status(s.StatusCodes.BAD_REQUEST).json({message:"Invalid ID provided"});const r=await i(a);if(!r)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Employee not found"});t.status(s.StatusCodes.OK).json({message:"Employee found",employee:r})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error retrieving employee",error:e.message})}})),c.post("/register",(async(e,t)=>{try{const i=`EMP${(0,a.nanoid)(5)}`,{name:c,phoneNumber:d,email:u,photo:l,address:E,govtId:m,Role:R,password:y,centerId:g}=e.body,{generatedId:h,token:C}=await(async(e,t,s,a,i,c,d,u,l,E)=>{try{const m=await o.genSalt(10),R=await o.hash(l,m),[y]=await r.query("INSERT INTO empDetails (id, Name, Phone, EmailAddr, Photo, Address, GovtID, Role, password,centerId) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?,?)",[e,t,s,a,i,c,d,u,R,E]),g=process.env.JWT_SECRET;return{generatedId:e,token:n.sign({id:e,UserName:t,userPhone:s,userEmail:a,userPhoto:i,userAddress:c,userId:d,centerId:E},g,{expiresIn:process.env.JWT_LIFETIME})}}catch(e){throw new Error("Error creating employee in the database")}})(i,c,d,u,l,E,m,R,y,g),S=`Data inserted: success. Employee ID: ${h}`;t.status(s.StatusCodes.CREATED).json({message:S,generatedId:h,token:C})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error registering employee",error:e.message})}})),c.post("/login",(async(e,t)=>{const{phoneNumber:s,password:a}=e.body;try{const{token:e,role:i,userId:c}=await(async(e,t)=>{try{const[s]=await r.query("SELECT * FROM empDetails WHERE Phone = ? LIMIT 1",[e]);if(0===s.length)return{message:"User not found"};const a=s[0],i=a.Role,c=a.id;if(!await o.compare(t,a.password))throw new Error("Invalid credentials");const d=process.env.JWT_SECRET;return{token:n.sign({userId:a.id,UserName:a.Name,userPhone:a.Phone,userEmail:a.EmailAddr,userPhoto:a.Photo,userAddress:a.Address,govtId:a.GovtID},d,{expiresIn:process.env.JWT_LIFETIME}),role:i,userId:c}}catch(e){throw new Error(`Error logging in: ${e.message}`)}})(s,a);if(!e)return void t.status(404).json({message:"User not found"});t.status(201).json({token:e,role:i,SalesExecId:c,message:"Login successful"})}catch(e){t.status(500).json({message:`Error logging in: ${e.message}`})}})),c.patch("/updateEmployeeById/:id",(async(e,t)=>{try{const{id:a}=e.params,o=e.body;if(!a)return t.status(s.StatusCodes.BAD_REQUEST).json({message:"Invalid ID provided"});const n=await(async(e,t)=>{const{name:s,phoneNumber:a,email:o,photo:n,address:c,govtId:d,role:u,password:l}=t,E={};s&&(E.Name=s),a&&(E.Phone=a),o&&(E.EmailAddr=o),n&&(E.Photo=n),c&&(E.Address=c),d&&(E.GovtID=d),u&&(E.Role=u),l&&(E.password=l);try{const[t]=await r.query("UPDATE empDetails SET ? WHERE id = ?",[E,e]);return 0===t.affectedRows?null:await i(e)}catch(e){throw new Error("Error updating employee in the database")}})(a,o);if(!n)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Employee not found or not updated"});t.status(s.StatusCodes.OK).json({message:"Employee updated successfully",updatedEmployee:n})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error updating employee",error:e.message})}})),c.delete("/deleteEmployeeById/:id",(async(e,t)=>{try{const{id:a}=e.params;if(!a)return t.status(s.StatusCodes.BAD_REQUEST).json({message:"Invalid ID provided"});const o=await(async e=>{try{const[t]=await r.query("DELETE FROM empDetails WHERE id = ?",[e]);return 0!==t.affectedRows}catch(e){throw new Error("Error deleting employee from the database")}})(a);if(!o)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Employee not found or already deleted"});t.status(s.StatusCodes.OK).json({message:"Employee deleted successfully"})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error deleting employee",error:e.message})}}));const d=c,u=async e=>{try{const t="SELECT * FROM roleDetails WHERE id = ?",[s]=await r.query(t,[e]);return 0===s.length?null:s[0]}catch(e){throw new Error("Error retrieving role from the database")}},l=e.Router();l.get("/getAllRoles",(async(e,t)=>{try{const e=await(async()=>{try{const e="SELECT * FROM roleDetails",[t]=await r.query(e);return t}catch(e){throw new Error("Error retrieving roles from the database")}})();return e.length>0?t.status(s.StatusCodes.OK).json({message:"Roles retrieved successfully",roles:e}):t.status(s.StatusCodes.NOT_FOUND).json({message:"No roles found"})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error retrieving roles",error:e.message})}})),l.get("/getRoleById/:id",(async(e,t)=>{try{const{id:a}=e.params;if(!a)return t.status(s.StatusCodes.BAD_REQUEST).json({message:"Invalid role ID provided"});const r=await u(a);return r?t.status(s.StatusCodes.OK).json({message:"Role retrieved successfully",role:r}):t.status(s.StatusCodes.NOT_FOUND).json({message:"Role not found"})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error retrieving role",error:e.message})}})),l.post("/createRole",(async(e,t)=>{try{const{roleTitle:o,createdOn:n,createdBy:i}=e.body;if(!o||!i)return t.status(s.StatusCodes.BAD_REQUEST).json({message:"RoleTitle and CreatedBy are required fields"});const c=(0,a.nanoid)(10),d=await(async(e,t,s,a)=>{try{const o="INSERT INTO roleDetails (id, RoleTitle, CreatedOn, CreatedBy) VALUES (?, ?, ?, ?)",[n]=await r.query(o,[e,t,s,a]);return n}catch(e){throw new Error("Error creating role in the database")}})(c,o,n,i);return d?t.status(s.StatusCodes.CREATED).json({message:"Role created successfully",id:c}):t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Failed to create role"})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error creating role",error:e.message})}})),l.patch("/updateRoleById/:id",(async(e,t)=>{try{const{id:a}=e.params,o=e.body;if(!a)return t.status(s.StatusCodes.BAD_REQUEST).json({message:"Invalid ID provided"});const n=await(async(e,t)=>{const{roleTitle:s,createdOn:a,createdBy:o}=t,n={};void 0!==s&&(n.RoleTitle=s),void 0!==a&&(n.CreatedOn=a),void 0!==o&&(n.CreatedBy=o);try{const t=Object.entries(n),s=t.map((([e,t])=>t));s.push(e);const a=`UPDATE roleDetails SET ${t.map((([e])=>`${e} = ?`)).join(", ")} WHERE id = ?`,[o]=await r.query(a,s);return 0===o.affectedRows?null:await u(e)}catch(e){throw new Error("Error updating role in the database")}})(a,o);if(!n)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Role not found or not updated"});const i=await u(a);t.status(s.StatusCodes.OK).json({message:"Role updated successfully",updatedRole:i})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error updating role",error:e.message})}})),l.delete("/deleteRoleById/:id",(async(e,t)=>{try{const{id:a}=e.params;return a?await(async e=>{try{const t="DELETE FROM roleDetails WHERE id = ?",[s]=await r.query(t,[e]);return 0!==s.affectedRows}catch(e){throw new Error("Error deleting role from the database")}})(a)?t.status(s.StatusCodes.OK).json({message:"Role deleted successfully"}):t.status(s.StatusCodes.NOT_FOUND).json({message:"Role not found or already deleted"}):t.status(s.StatusCodes.BAD_REQUEST).json({message:"Invalid role ID provided"})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error deleting role",error:e.message})}}));const E=l,m=async e=>{try{const t="SELECT * FROM clientpersonal WHERE CustomerId = ?",[s]=await r.query(t,[e]);return 0===s.length?null:s[0]}catch(e){throw new Error("Error retrieving client personal details from the database")}},R=e.Router();R.post("/createClientPersonalDetails",(async(e,t)=>{try{const{centerId:o,customerName:n,spouseName:i,fatherName:c,motherName:d,dateOfBirth:u,age:l,address:E,residenceCustYr:m,mobileNo1:R,mobileNo2:y,isTatchedHouse:g,isRoofTiles:h,isMetalsheets:C,isCementSheetsRoof:S,isCementConcreteCeil:p,isHindu:w,isMuslim:N,isChristian:f,isOthers:I,isMarried:O,isSingle:T,isWidow:D,isDivorced:j,isSeparate:A,isOwned:b,isRented:_,SalesExecID:L}=e.body,v=`CL${(0,a.nanoid)(5)}`;await(async(e,t,s,a,o,n,i,c,d,u,l,E,m=!1,R=!1,y=!1,g=!1,h=!1,C=!1,S=!1,p=!1,w=!1,N=!1,f=!1,I=!1,O=!1,T=!1,D=!1,j=!1,A)=>{try{const b="INSERT INTO ClientPersonal (\n      centerId, CustomerId, CustomerName, SpouseName, FatherName, MotherName,\n      DateOfBirth, Age, Address, ResidenceCustYr, MobileNo1, MobileNo2,\n      isTatchedHouse, isRoofTiles, isMetalsheets, isCementSheetsRoof,\n      isCementConcreteCeil, isHindu, isMuslim, isChristian, isOthers,\n      isMarried, isSingle, isWidow, isDivorced, isSeparate, isOwned, isRented,SalesExecID\n    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?)",[_]=await r.query(b,[e,t,s,a,o,n,i,c,d,u,l,E,m,R,y,g,h,C,S,p,w,N,f,I,O,T,D,j,A]);return _}catch(e){throw new Error("Error creating client personal details in the database")}})(o,v,n,i,c,d,u,l,E,m,R,y,g,h,C,S,p,w,N,f,I,O,T,D,j,A,b,_,L),t.status(s.StatusCodes.CREATED).json({message:"Client personal details created successfully",customerId:v})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error creating client personal details",error:e.message})}})),R.get("/getClientPersonalDetailsById/:customerId",(async(e,t)=>{try{const{customerId:a}=e.params,r=await m(a);if(!r)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Client personal details not found"});t.status(s.StatusCodes.OK).json({message:"Client personal details retrieved successfully",clientPersonal:r})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error retrieving client personal details",error:e.message})}})),R.get("/getAllClientPersonalDetails",(async(e,t)=>{try{const{MobileNo1:a,salesExecID:o}=e.query,{clients:n,count:i}=await(async({MobileNo1:e,salesExecID:t})=>{try{let s="SELECT * FROM ClientPersonal WHERE 1";const a=[];e&&(s+=" AND MobileNo1 = ?",a.push(e)),t&&(s+=" AND salesExecID = ?",a.push(t)),console.log(s);const[o]=await r.query(s,a);return{clients:o,count:o.length}}catch(e){throw new Error("Error retrieving client personal details with given parameters from the database")}})({MobileNo1:a,salesExecID:o}),c=`Retrieved ${i} clients`;t.status(s.StatusCodes.OK).json({message:c,clients:n,count:i})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error retrieving client personal details",error:e.message})}})),R.patch("/updateClientPersonalDetailsById/:customerId",(async(e,t)=>{try{const{customerId:a}=e.params,o=e.body,n=await(async(e,t)=>{const s={...t};try{const t=Object.entries(s),a=t.map((([e,t])=>t));a.push(e);const o=`UPDATE ClientPersonal SET ${t.map((([e])=>`${e} = ?`)).join(", ")} WHERE CustomerId = ?`,[n]=await r.query(o,a);return 0!==n.affectedRows}catch(e){throw console.log(e),new Error("Error updating client personal details in the database")}})(a,o);if(!n)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Client personal details not found or not updated"});const i=await m(a);t.status(s.StatusCodes.OK).json({message:"Client personal details updated successfully",updatedDetails:i})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"INTERNAL_SERVER_ERROR",error:e.message})}})),R.delete("/deleteClientPersonalDetailsById/:customerId",(async(e,t)=>{try{const{customerId:a}=e.params,o=await(async e=>{try{const t="DELETE FROM ClientPersonal WHERE CutomerID = ?",[s]=await r.query(t,[e]);return 0!==s.affectedRows}catch(e){throw new Error("Error deleting client personal details from the database")}})(a);if(!o)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Client personal details not found or not deleted"});t.status(s.StatusCodes.OK).json({message:"Client personal details deleted successfully"})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error deleting client personal details",error:e.message})}}));const y=R,g=async e=>{try{const t="SELECT * FROM ClientGuarantorDetails WHERE GuarentorID = ?",[s]=await r.query(t,[e]);return 0===s.length?null:s[0]}catch(e){throw new Error("Error retrieving client guarantor details from the database")}},h=e.Router();h.get("/getAllClientGuarantorDetails",(async(e,t)=>{try{const e=await(async()=>{try{const e="SELECT * FROM ClientGuarantorDetails",[t]=await r.query(e);return t}catch(e){throw new Error("Error retrieving client guarantor details from the database")}})();t.status(s.StatusCodes.OK).json({result:e})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error retrieving client guarantor details",error:e.message})}})),h.get("/getClientGuarantorById/:guarantorId",(async(e,t)=>{try{const{guarantorId:a}=e.params,r=await g(a);if(!r)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Client guarantor details not found"});t.status(s.StatusCodes.OK).json({result:r})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error retrieving client guarantor details",error:e.message})}})),h.post("/createClientGuarantorDetails",(async(e,t)=>{try{const{customerId:o,guarantorName:n,spouseName:i,fatherName:c,motherName:d,relation:u,dateOfBirth:l,age:E,grMobileNo1:m,grMobileNo2:R,grAddress:y,grIsOwned:g,grIsRented:h}=e.body,C=(0,a.nanoid)(10);await(async(e,t,s,a,o,n,i,c,d,u,l,E,m=!1,R=!1)=>{try{const y="INSERT INTO ClientGuarantorDetails (\n      GuarentorID, CustomerID, GuarantorName, SpouseName, FatherName, MotherName,\n      Relation, DateOfBirth, Age, GrMobileNo1, GrMobileNo2, GrAddress,\n      GrIsOwned, GrIsRented\n    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",[g]=await r.query(y,[e,t,s,a,o,n,i,c,d,u,l,E,m,R]);return g}catch(e){throw new Error("Error creating client guarantor details in the database")}})(C,o,n,i,c,d,u,l,E,m,R,y,g,h),t.status(s.StatusCodes.CREATED).json({message:"Client guarantor details created successfully",guarantorId:C})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error creating client guarantor details",error:e.message})}})),h.patch("/updateClientGuarantorById/:guarantorId",(async(e,t)=>{try{const{guarantorId:a}=e.params,o=e.body,n=await(async(e,t)=>{try{const s=Object.entries(t),a=s.map((([e,t])=>t));a.push(e);const o=`UPDATE clientguarantordetails SET ${s.map((([e])=>`${e} = ?`)).join(", ")} WHERE GuarentorID = ?`,[n]=await r.query(o,a);return n.affectedRows>0}catch(e){throw console.log(e),console.error("Error updating client guarantor details:",e),e}})(a,o);if(console.log(n),!n)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Client guarantor details not found or not updated"});const i=await g(a);t.status(s.StatusCodes.OK).json({message:"Client guarantor details updated successfully",updatedDetails:i})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error updating client guarantor details",error:e.message})}})),h.delete("/deleteClientGuarantorById/:guarantorId",(async(e,t)=>{try{const{guarantorId:a}=e.params,o=await(async e=>{try{const t="DELETE FROM ClientGuarantorDetails WHERE GuarentorID = ?",[s]=await r.query(t,[e]);return 0!==s.affectedRows}catch(e){throw new Error("Error deleting client guarantor details from the database")}})(a);if(!o)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Client guarantor details not found or not deleted"});t.status(s.StatusCodes.OK).json({message:"Client guarantor details deleted successfully"})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error deleting client guarantor details",error:e.message})}}));const C=h,S=async e=>{try{const t="SELECT * FROM ClientBankDetails WHERE id = ?",[s]=await r.query(t,[e]);return 0===s.length?null:s[0]}catch(e){throw new Error("Error retrieving client bank details from the database")}},p=e.Router();p.post("/createClientBankDetails",(async(e,t)=>{try{const{clientID:o,AccountNo:n,IFSC:i,BranchName:c,BankName:d}=e.body,u=(0,a.nanoid)(10),l=await(async(e,t,s,a,o,n)=>{try{const i="INSERT INTO ClientBankDetails (id, clientID, AccountNo, IFSC, BranchName, BankName) VALUES (?, ?, ?, ?, ?, ?)",[c]=await r.query(i,[e,t,s,a,o,n]);if(0===c.affectedRows)throw new Error("Error creating client bank details in the database");return{result:c}}catch(e){throw console.log(e),new Error("Error creating client bank details in the database")}})(u,o,n,i,c,d);t.status(s.StatusCodes.CREATED).json({message:"Client bank details created successfully",result:l,id:u})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error creating client bank details",error:e.message})}})),p.get("/getAllClientBankDetails",(async(e,t)=>{try{const e=await(async()=>{try{const e="SELECT * FROM ClientBankDetails",[t]=await r.query(e);return t}catch(e){throw new Error("Error retrieving client bank details from the database")}})();t.status(s.StatusCodes.OK).json(e)}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error retrieving client bank details",error:e.message})}})),p.get("/getClientBankDetailsById/:id",(async(e,t)=>{try{const{id:a}=e.params,r=await S(a);if(!r)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Client bank details not found"});t.status(s.StatusCodes.OK).json({result:r})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error retrieving client bank details",error:e.message})}})),p.patch("/updateClientBankDetailsById/:id",(async(e,t)=>{try{const{id:a}=e.params,o=e.body,n=await(async(e,t)=>{try{const s=Object.entries(t),a=s.map((([e,t])=>t));a.push(e);const o=`UPDATE ClientBankDetails SET ${s.map((([e])=>`${e} = ?`)).join(", ")} WHERE id = ?`,[n]=await r.query(o,a);return 0!==n.affectedRows&&await S(e)}catch(e){throw console.log(e),new Error("Error updating client bank details in the database")}})(a,o);if(console.log(n),!n)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Client bank details not found or not updated",result:n});const i=await S(a);t.status(s.StatusCodes.OK).json({message:"Client bank details updated successfully",result:i})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error updating client bank details",error:e.message})}})),p.patch("/updateClientBankDetailsByClientId/:id",(async(e,t)=>{try{const{id:a}=e.params,o=e.body,n=await(async(e,t)=>{try{const s=Object.entries(t),a=s.map((([e,t])=>t));a.push(e);const o=`UPDATE ClientBankDetails SET ${s.map((([e])=>`${e} = ?`)).join(", ")} WHERE clientID = ?`,[n]=await r.query(o,a);return console.log(o),0!==n.affectedRows&&(await S(n.id),console.log(n),!0)}catch(e){throw console.log(e),new Error("Error updating client bank details in the database")}})(a,o);if(console.log(n),!n)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Client bank details not found or not updated"});const i=await S(a);t.status(s.StatusCodes.OK).json({message:"Client bank details updated successfully",result:i})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error updating client bank details",error:e.message})}})),p.delete("/deleteClientBankDetailsById/:id",(async(e,t)=>{try{const{id:a}=e.params,o=await(async e=>{try{const t="DELETE FROM ClientBankDetails WHERE id = ?",[s]=await r.query(t,[e]);return 0!==s.affectedRows}catch(e){throw new Error("Error deleting client bank details from the database")}})(a);if(!o)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Client bank details not found or not deleted"});t.status(s.StatusCodes.OK).json({message:"Client bank details deleted successfully"})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error deleting client bank details",error:e.message})}}));const w=p,N=async e=>{try{const t="SELECT * FROM clientHouseHoldDetails WHERE id = ?",[s]=await r.query(t,[e]);return 0===s.length?null:s[0]}catch(e){throw new Error("Error retrieving client house hold details from the database")}},f=e.Router();f.post("/createHouseHoldDtls",(async(e,t)=>{try{const{Loan:o,Education:n,Rent:i,Medical:c,Others:d,Total:u,TotalIncome:l,TotalExpenses:E,Balance:m,customerId:R}=e.body,y=(0,a.nanoid)(),g=await(async(e,t,s,a,o,n,i,c,d,u,l)=>{try{const E="INSERT INTO clientHouseHoldDetails (\n      id,\n      Loan,\n      Education,\n      Rent,\n      Medical,\n      Others,\n      Total,\n      TotalIncome,\n      TotalExpenses,\n      Balance,\n      customerId\n    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",[m]=await r.query(E,[e,t,s,a,o,n,i,c,d,u,l]);return m}catch(e){throw console.log(e),new Error("Error creating client house hold details in the database")}})(y,o,n,i,c,d,u,l,E,m,R);t.status(s.StatusCodes.CREATED).json({message:"Client house hold details created successfully",result:g,id:y})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error creating client house hold details",error:e.message})}})),f.get("/getAllHouseHoldDtls",(async(e,t)=>{try{const e=await(async()=>{try{const e="SELECT * FROM clientHouseHoldDetails",[t]=await r.query(e);return t}catch(e){throw new Error("Error retrieving client house hold details from the database")}})();t.status(s.StatusCodes.OK).json({message:"Retrieved all client house hold details",clientHouseHold:e})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error retrieving client house hold details",error:e.message})}})),f.get("/getHouseHoldDtlsById/:id",(async(e,t)=>{try{const{id:a}=e.params;if(!a)return t.status(s.StatusCodes.BAD_REQUEST).json({message:"Invalid ID provided"});const r=await N(a);if(!r)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Client house hold details not found"});t.status(s.StatusCodes.OK).json({message:"Client house hold details found",clientHouseHold:r})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error retrieving client house hold details",error:e.message})}})),f.patch("/updateClientHouseHoldById/:id",(async(e,t)=>{try{const{id:a}=e.params,o=e.body;if(!a)return t.status(s.StatusCodes.BAD_REQUEST).json({message:"Invalid ID provided"});const n=await(async(e,t)=>{try{const s=Object.entries(t),a=s.map((([e,t])=>t));a.push(e);const o=`UPDATE clienthouseholddetails SET ${s.map((([e])=>`${e} = ?`)).join(", ")} WHERE id = ?`,[n]=await r.query(o,a);return 0!==n.affectedRows&&await N(e)}catch(e){throw console.log(e),new Error("Error updating client house hold details in the database")}})(a,o);if(!n)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Client house hold details not found or not updated"});t.status(s.StatusCodes.OK).json({message:"Client house hold details updated successfully",updatedClientHouseHold:n})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error updating client house hold details",error:e.message})}})),f.delete("/deleteClientHouseHoldById/:id",(async(e,t)=>{try{const{id:a}=e.params;if(!a)return t.status(s.StatusCodes.BAD_REQUEST).json({message:"Invalid ID provided"});const o=await(async e=>{try{const t="DELETE FROM clientHouseHoldDetails WHERE id = ?",[s]=await r.query(t,[e]);return 0!==s.affectedRows}catch(e){throw new Error("Error deleting client house hold details from the database")}})(a);if(!o)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Client house hold details not found or already deleted"});t.status(s.StatusCodes.OK).json({message:"Client house hold details deleted successfully"})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error deleting client house hold details",error:e.message})}}));const I=f,O=async e=>{try{const t="SELECT * FROM clientverificationid WHERE id = ?",[s]=await r.query(t,[e]);return 0===s.length?null:s[0]}catch(e){throw console.log(e),new Error("Error retrieving client verification details from the database")}},T=e.Router();T.post("/createVerification",(async(e,t)=>{try{const{GrSmartCard:o,GrAadharCard:n,GrPanCard:i,GrVoterId:c,GrOthers1:d,GrOthers2:u,ClSmartCard:l,ClAadharCard:E,ClVoterId:m,ClPanCard:R,ClOthers1:y,ClOthers2:g,customerId:h}=e.body,C=(0,a.nanoid)(),S=await(async(e,t,s,a,o,n,i,c,d,u,l,E,m,R)=>{try{const y="INSERT INTO clientVerificationId (\n      id, GrSmartCard, GrAadharCard, GrPanCard,GrVoterId, GrOthers1, GrOthers2,\n      ClSmartCard, ClAadharCard, ClVoterId, ClPanCard, ClOthers1, ClOthers2, customerId\n    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?)",[g]=await r.query(y,[e,t,s,a,o,n,i,c,d,u,l,E,m,R]);return g}catch(e){throw new Error("Error creating client verification details in the database")}})(C,o,n,i,c,d,u,l,E,m,R,y,g,h);t.status(s.StatusCodes.CREATED).json({message:"Client verification details created successfully",result:S,id:C})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error creating client verification details",error:e.message})}})),T.get("/getAllVerification",(async(e,t)=>{try{const e=await(async()=>{try{const e="SELECT * FROM clientVerificationId",[t]=await r.query(e);return t}catch(e){throw new Error("Error retrieving client verification details from the database")}})();t.status(s.StatusCodes.OK).json({message:"Retrieved all client verification details",clientVerifications:e})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error retrieving client verification details",error:e.message})}})),T.get("/getVerificationById/:id",(async(e,t)=>{try{const{id:a}=e.params,r=await O(a);if(!r)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Client verification not found"});t.status(s.StatusCodes.OK).json({message:"Client verification found",clientVerification:r})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error retrieving client verification",error:e.message})}})),T.patch("/updateVerification/:id",(async(e,t)=>{try{const{id:a}=e.params,o=e.body,n=await(async(e,t)=>{const s={...t};try{const t=Object.entries(s),a=t.map((([e,t])=>t));a.push(e);const o=`UPDATE clientverificationid SET ${t.map((([e])=>`${e} = ?`)).join(", ")} WHERE id = ?`,[n]=await r.query(o,a);if(0===n.affectedRows)return null;const i=await O(e);return console.log(n),i}catch(e){throw console.log(e),new Error("Error updating client verification details in the database")}})(a,o);if(!n)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Client verification not found or not updated"});t.status(s.StatusCodes.OK).json({message:"Client verification updated successfully",updatedClientVerification:n})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error updating client verification",error:e.message})}})),T.delete("/deleteVerification/:id",(async(e,t)=>{try{const{id:a}=e.params,o=await(async e=>{try{const t="DELETE FROM clientverificationid WHERE id = ?",[s]=await r.query(t,[e]);return 0!==s.affectedRows}catch(e){throw new Error("Error deleting client verification details from the database")}})(a);if(!o)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Client verification not found or already deleted"});t.status(s.StatusCodes.OK).json({message:"Client verification deleted successfully"})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error deleting client verification",error:e.message})}}));const D=T,j=async e=>{try{const t="SELECT * FROM MoneyRecord WHERE ID = ?",[s]=await r.query(t,[e]);return 0===s.length?null:s[0]}catch(e){throw new Error("Error retrieving entry from the database")}},A=e.Router();A.get("/getAllEntries",(async(e,t)=>{try{const{SalesExecID:a,DateOfLoan:o,DateOfCollection:n,CenterID:i,CustomerID:c,LoanAmount:d,CurrentPayCount:u,PayCount:l,PrincipalAmount:E,Status:m}=e.query,R=await(async({SalesExecID:e,dateOfLoan:t,DayOfCollection:s,CenterID:a,CustomerID:o,LoanAmount:n,CurrentPayCount:i,PayCount:c,PrincipalAmount:d,Status:u})=>{try{let l="SELECT * FROM MoneyRecord WHERE 1";const E=[];e&&(l+=" AND SalesExecID = ?",E.push(e)),t&&(l+=" AND dateOfLoan = ?",E.push(t)),s&&(l+=" AND DayOfCollection = ?",E.push(s)),a&&(l+=" AND CenterID = ?",E.push(a)),o&&(l+=" AND CustomerID = ?",E.push(o)),n&&(l+=" AND LoanAmount = ?",E.push(n)),i&&(l+=" AND CurrentPayCount = ?",E.push(i)),c&&(l+=" AND PayCount = ?",E.push(c)),d&&(l+=" AND PrincipalAmount = ?",E.push(d)),u&&(l+=" AND Status = ?",E.push(u));const[m]=await r.query(l,E);return{entries:m,count:m.length}}catch(e){throw new Error("Error retrieving entries from the database")}})({SalesExecID:a,DateOfLoan:o,DateOfCollection:n,CenterID:i,CustomerID:c,LoanAmount:d,CurrentPayCount:u,PayCount:l,PrincipalAmount:E,Status:m});t.status(s.StatusCodes.OK).json(R)}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error retrieving entries",error:e.message})}})),A.get("/getEntryById/:id",(async(e,t)=>{try{const{id:a}=e.params,r=await j(a);if(!r)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Entry not found"});t.status(s.StatusCodes.OK).json(r)}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error retrieving entry",error:e.message})}})),A.post("/createEntry",(async(e,t)=>{try{const{SalesExecID:o,Date:n,CollectionDate:i,CenterID:c,CustomerID:d,LoanAmount:u,Interest:l,CurrentPayCount:E,PayCount:m,PrincipalAmount:R,Status:y}=e.body,g=`TRANS${(0,a.nanoid)(5)}`,h=await(async(e,t,s,a,o,n,i,c,d,u,l,E)=>{try{const m="INSERT INTO MoneyRecord (ID, SalesExecID, dateOfLoan, DayOfCollection, CenterID, CustomerID, LoanAmount, Interest, CurrentPayCount, PayCount, PrincipalAmount, Status) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",[R]=await r.query(m,[e,t,s,a,o,n,i,c,d,u,l,E]);return console.log("Inserted Cash Flow Entry:",R),R}catch(e){throw console.error("Error creating cash flow entry in the database:",e.message),new Error("Error creating cash flow entry in the database")}})(g,o,n,i,c,d,u,l,E,m,R,y);t.status(s.StatusCodes.CREATED).json({message:"Entry created successfully",result:h})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error creating entry",error:e.message})}})),A.patch("/updateEntryById/:id",(async(e,t)=>{try{const{id:a}=e.params,o=e.body,n=await(async(e,t)=>{try{const s=Object.entries(t),a=s.map((([e,t])=>t));a.push(e);const o=`UPDATE MoneyRecord SET ${s.map((([e])=>`${e} = ?`)).join(", ")} WHERE ID = ?`,[n]=await r.query(o,a);return 0!==n.affectedRows}catch(e){throw new Error("Error updating entry in the database")}})(a,o);if(!n)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Entry not found or not updated"});const i=await j(a);t.status(s.StatusCodes.OK).json({message:"Entry updated successfully",result:i})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error updating entry",error:e.message})}})),A.delete("/deleteEntryById/:id",(async(e,t)=>{try{const{id:a}=e.params;if(!await(async e=>{try{const t="DELETE FROM MoneyRecord WHERE ID = ?",[s]=await r.query(t,[e]);return 0!==s.affectedRows}catch(e){throw new Error("Error deleting entry from the database")}})(a))return t.status(s.StatusCodes.NOT_FOUND).json({message:"Entry not found or not deleted"});t.status(s.StatusCodes.OK).json({message:"Entry deleted successfully"})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error deleting entry",error:e.message})}}));const b=A,_=async e=>{try{const t="SELECT * FROM centerDetails WHERE id = ?",[s]=await r.query(t,[e]);return 0===s.length?null:s[0]}catch(e){throw new Error("Error retrieving center entry from the database")}},L=e.Router();L.get("/getAllCenterDetails",(async(e,t)=>{try{const{centerCode:a,centerName:o,IFSC:n,TotalAmount:i}=e.query,c=await(async({centerCode:e,centerName:t,IFSC:s,TotalAmount:a})=>{try{let o="SELECT * FROM centerDetails WHERE 1";const n=[];e&&(o+=" AND centerCode = ?",n.push(e)),t&&(o+=" AND centerName = ?",n.push(t)),s&&(o+=" AND IFSC = ?",n.push(s)),a&&(o+=" AND TotalAmount = ?",n.push(a));const[i]=await r.query(o,n);return{centers:i,count:i.length}}catch(e){throw new Error("Error retrieving center details with given parameters from the database")}})({centerCode:a,centerName:o,IFSC:n,TotalAmount:i});t.status(s.StatusCodes.OK).json(c)}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error retrieving center entries",error:e.message})}})),L.get("/getCenterDetailsById/:id",(async(e,t)=>{try{const{id:a}=e.params,r=await _(a);if(!r)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Center entry not found"});t.status(s.StatusCodes.OK).json(r)}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error retrieving center entry",error:e.message})}})),L.post("/createCenterDetails",(async(e,t)=>{try{const{centerCode:o,centerName:n,IFSC:i,TotalAmount:c,centerIncharge:d}=e.body,u=`CEN${(0,a.nanoid)(5)}`,l=await(async(e,t,s,a,o,n)=>{try{const i="INSERT INTO centerDetails (id, centerCode, centerName, IFSC, TotalAmount,centerIncharge) VALUES (?, ?, ?, ?, ?,?)",[c]=await r.query(i,[e,t,s,a,o,n]);return c}catch(e){throw new Error("Error creating center entry in the database")}})(u,o,n,i,c,d);t.status(s.StatusCodes.CREATED).json({message:"Center entry created successfully",result:l,id:u})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error creating center entry",error:e.message})}})),L.patch("/updateCenterDetailsById/:id",(async(e,t)=>{try{const{id:a}=e.params,o=e.body,n=await(async(e,t)=>{try{const s=Object.entries(t),a=s.map((([e,t])=>t));a.push(e);const o=`UPDATE centerDetails SET ${s.map((([e])=>`${e} = ?`)).join(", ")} WHERE id = ?`,[n]=await r.query(o,a);return 0!==n.affectedRows}catch(e){throw new Error("Error updating center entry in the database")}})(a,o);if(!n)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Center entry not found or not updated"});const i=await _(a);t.status(s.StatusCodes.OK).json({message:"Center entry updated successfully",result:i})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error updating center entry",error:e.message})}})),L.delete("/deleteCenterDetailsById/:id",(async(e,t)=>{try{const{id:a}=e.params,o=await(async e=>{try{const t="DELETE FROM centerDetails WHERE id = ?",[s]=await r.query(t,[e]);return 0!==s.affectedRows}catch(e){throw new Error("Error deleting center entry from the database")}})(a);if(!o)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Center entry not found or not deleted"});t.status(s.StatusCodes.OK).json({message:"Center entry deleted successfully"})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error deleting center entry",error:e.message})}}));const v=L,F=async e=>{try{const t="SELECT * FROM TransactionLogs WHERE TransId = ?",[s]=await r.query(t,[e]);return 0===s.length?null:s[0]}catch(e){throw new Error("Error retrieving transaction log from the database")}},V=e.Router();V.post("/createTransactionLog",(async(e,t)=>{try{const{date:o,amount:n,typeOfTrans:i,investorId:c,centerId:d,salesExecId:u,clientId:l,modeOfTrans:E}=e.body,m=`TRAN${(0,a.nanoid)(5)}`,R=await(async(e,t,s,a,o,n,i,c,d)=>{try{const u="INSERT INTO TransactionLogs (TransId, Date, Amount, TypeOfTrans, InvestorId, CenterId, SalesExecId, ClientId, ModeOfTrans) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",[l]=await r.query(u,[e,t,s,a,o,n,i,c,d]);if(0===l.affectedRows)throw new Error("Error creating transaction log in the database");return{result:l}}catch(e){throw console.log(e),new Error("Error creating transaction log in the database")}})(m,o,n,i,c,d,u,l,E);t.status(s.StatusCodes.CREATED).json({message:"Transaction log created successfully",result:R,transId:m})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error creating transaction log",error:e.message})}})),V.get("/getAllTransactionLogs",(async(e,t)=>{try{const{date:a,typeOfTrans:o,investorId:n,centerId:i,salesExecId:c,clientId:d}=e.query,u=await(async({date:e,typeOfTrans:t,investorId:s,centerId:a,salesExecId:o,clientId:n})=>{try{let i="SELECT * FROM TransactionLogs WHERE 1";const c=[];e&&(i+=" AND Date = ?",c.push(e)),t&&(i+=" AND TypeOfTrans = ?",c.push(t)),s&&(i+=" AND InvestorId = ?",c.push(s)),a&&(i+=" AND CenterId = ?",c.push(a)),o&&(i+=" AND SalesExecId = ?",c.push(o)),n&&(i+=" AND ClientId = ?",c.push(n));const[d,u]=await r.query(i,c);return{transactionLogs:d,count:d.length}}catch(e){throw new Error("Error retrieving transaction logs from the database")}})({date:a,typeOfTrans:o,investorId:n,centerId:i,salesExecId:c,clientId:d});t.status(s.StatusCodes.OK).json(u)}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error retrieving transaction logs",error:e.message})}})),V.get("/getTransactionLogById/:transId",(async(e,t)=>{try{const{transId:a}=e.params,r=await F(a);if(!r)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Transaction log not found"});t.status(s.StatusCodes.OK).json({result:r})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error retrieving transaction log",error:e.message})}})),V.patch("/updateTransactionLogById/:transId",(async(e,t)=>{try{const{transId:a}=e.params,o=e.body,n=await(async(e,t)=>{try{const s=Object.entries(t),a=s.map((([e,t])=>t));a.push(e);const o=`UPDATE TransactionLogs SET ${s.map((([e])=>`${e} = ?`)).join(", ")} WHERE TransId = ?`,[n]=await r.query(o,a);return 0!==n.affectedRows&&await F(e)}catch(e){throw console.log(e),new Error("Error updating transaction log in the database")}})(a,o);if(!n)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Transaction log not found or not updated",result:n});const i=await F(a);t.status(s.StatusCodes.OK).json({message:"Transaction log updated successfully",result:i})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error updating transaction log",error:e.message})}})),V.delete("/deleteTransactionLogById/:transId",(async(e,t)=>{try{const{transId:a}=e.params,o=await(async e=>{try{const t="DELETE FROM TransactionLogs WHERE TransId = ?",[s]=await r.query(t,[e]);return 0!==s.affectedRows}catch(e){throw new Error("Error deleting transaction log from the database")}})(a);if(!o)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Transaction log not found or not deleted"});t.status(s.StatusCodes.OK).json({message:"Transaction log deleted successfully"})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error deleting transaction log",error:e.message})}}));const q=V,M=async e=>{try{const t="SELECT * FROM familydetails WHERE id = ?",[s]=await r.query(t,[e]);return 0===s.length?null:s[0]}catch(e){throw new Error("Error retrieving family member from the database")}},U=e.Router();U.post("/createFamilyMember",(async(e,t)=>{try{const{clientId:o,member1:n,relation1:i,age1:c,occupation1:d,education1:u,income1:l,member2:E,relation2:m,age2:R,occupation2:y,education2:g,income2:h,member3:C,relation3:S,age3:p,occupation3:w,education3:N,income3:f,member4:I,relation4:O,age4:T,occupation4:D,education4:j,income4:A,member5:b,relation5:_,age5:L,occupation5:v,education5:F,income5:V}=e.body,q=`FAM${(0,a.nanoid)(5)}`,M=await(async(e,t,s,a,o,n,i,c,d,u,l,E,m,R,y,g,h,C,S,p,w,N,f,I,O,T,D,j,A,b,_,L)=>{try{const v="INSERT INTO familydetails (\n      member1, relation1, age1, occupation1, education1, income1,\n      member2, relation2, age2, occupation2, education2, income2,\n      member3, relation3, age3, occupation3, education3, income3,\n      member4, relation4, age4, occupation4, education4, income4,\n      member5, relation5, age5, occupation5, education5, income5,\n      id, clientId\n    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?)",[F]=await r.query(v,[s,a,o,n,i,c,d,u,l,E,m,R,y,g,h,C,S,p,w,N,f,I,O,T,D,j,A,b,_,L,e,t]);return console.log("Inserted Family Member:",F),F}catch(e){throw console.error("Error creating family member in the database:",e.message),new Error("Error creating family member in the database")}})(q,o,n,i,c,d,u,l,E,m,R,y,g,h,C,S,p,w,N,f,I,O,T,D,j,A,b,_,L,v,F,V);t.status(s.StatusCodes.CREATED).json({message:"Family member created successfully",result:M,id:q})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error creating family member",error:e.message})}})),U.get("/getAllFamilyMembers",(async(e,t)=>{try{const{clientId:a}=e.query,o=await(async e=>{try{let t="SELECT * FROM familydetails WHERE 1";const s=[];e&&(t+=" AND clientId = ?",s.push(e));const[a]=await r.query(t,s);return{familyMembers:a,count:a.length}}catch(e){throw console.log(e),new Error("Error retrieving family members from the database")}})(a);t.status(s.StatusCodes.OK).json(o)}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error retrieving family members",error:e.message})}})),U.get("/getFamilyMemberById/:id",(async(e,t)=>{try{const{id:a}=e.params,r=await M(a);if(!r)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Family member not found"});t.status(s.StatusCodes.OK).json({result:r})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error retrieving family member",error:e.message})}})),U.patch("/updateFamilyMemberById/:id",(async(e,t)=>{try{const{id:a}=e.params,o=e.body,n=await(async(e,t)=>{try{const s=Object.entries(t),a=s.map((([e,t])=>t));a.push(e);const o=`UPDATE familydetails SET ${s.map((([e])=>`${e} = ?`)).join(", ")} WHERE id = ?`,[n]=await r.query(o,a);return 0!==n.affectedRows}catch(e){throw new Error("Error updating family member in the database")}})(a,o);if(!n)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Family member not found or not updated",result:n});const i=await M(a);t.status(s.StatusCodes.OK).json({message:"Family member updated successfully",result:i})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error updating family member",error:e.message})}})),U.delete("/deleteFamilyMemberById/:id",(async(e,t)=>{try{const{id:a}=e.params,o=await(async e=>{try{const t="DELETE FROM familydetails WHERE id = ?",[s]=await r.query(t,[e]);return 0!==s.affectedRows}catch(e){throw new Error("Error deleting family member from the database")}})(a);if(!o)return t.status(s.StatusCodes.NOT_FOUND).json({message:"Family member not found or not deleted"});t.status(s.StatusCodes.OK).json({message:"Family member deleted successfully"})}catch(e){t.status(s.StatusCodes.INTERNAL_SERVER_ERROR).json({message:"Error deleting family member",error:e.message})}}));const B=U,H=e();H.use(e.json()),H.use(t()),H.use("/api/v1/employee",d),H.use("/api/v1/roles",E),H.use("/api/v1/client",y),H.use("/api/v1/client/guarantor",C),H.use("/api/v1/client/bankdetails",w),H.use("/api/v1/client/household",I),H.use("/api/v1/client/verification",D),H.use("/api/v1/client/family",B),H.use("/api/v1/MoneyRecord",b),H.use("/api/v1/center",v),H.use("/api/v1/transaction",q);const P=process.env.PORT||5e3;(async()=>{try{H.listen(P,(()=>console.log(`LenderApp Server is listening on port ${P}...`)))}catch(e){console.log(e)}})()})();